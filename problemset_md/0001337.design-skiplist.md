# Design Skiplist 设计跳表

[0001337] Hard

- https://leetcode-cn.com/problems/design-skiplist/

Topic Tags:

- [Design 设计](https://leetcode-cn.com/tag/design/)

Design a Skiplist without using any built-in libraries.

_A Skiplist is a data structure that takes O(log(n)) time to `add`, `erase` and `search`. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists are just simple linked lists._

_For example: we have a Skiplist containing `[30,40,50,60,70,90]` and we want to add `80` and `45` into it. The Skiplist works this way:_

![](https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif)  
Artyom Kalinin \[CC BY-SA 3.0\], via [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif "Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons")

_You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, `add` , `erase` and `search` can be faster than O(n). It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n)._

To be specific, your design should include these functions:

- `bool search(int target)` : Return whether the `target` exists in the Skiplist or not.
- `void add(int num)`: Insert a value into the SkipList.
- `bool erase(int num)`: Remove a value in the Skiplist. If `num` does not exist in the Skiplist, do nothing and return false. If there exists multiple `num` values, removing any one of them is fine.

See more about Skiplist : [https://en.wikipedia.org/wiki/Skip_list](https://en.wikipedia.org/wiki/Skip_list)

Note that duplicates may exist in the Skiplist, your code needs to handle this situation.

**Example:**

<pre>Skiplist skiplist = new Skiplist();

skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0);   // return false.
skiplist.add(4);
skiplist.search(1);   // return true.
skiplist.erase(0);    // return false, 0 is not in skiplist.
skiplist.erase(1);    // return true.
skiplist.search(1);   // return false, 1 has already been erased.</pre>

**Constraints:**

- `0 <= num, target <= 20000`
- At most `50000` calls will be made to `search`, `add`, and `erase`.

## 翻译

不使用任何库函数，设计一个跳表。

跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。

例如，一个跳表包含 \[30, 40, 50, 60, 70, 90\]，然后增加 80、45 到跳表中，以下图的方式操作：

![](https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif)  
Artyom Kalinin \[CC BY-SA 3.0\], via [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif "Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons")

跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。

在本题中，你的设计应该要包含这些函数：

- `bool search(int target)` : 返回 target 是否存在于跳表中。
- `void add(int num)`:  插入一个元素到跳表。
- `bool erase(int num)`: 在跳表中删除一个值，如果  `num`  不存在，直接返回 false. 如果存在多个  `num` ，删除其中任意一个即可。

了解更多 : [https://en.wikipedia.org/wiki/Skip_list](https://en.wikipedia.org/wiki/Skip_list)

注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。

**样例:**

<pre>Skiplist skiplist = new Skiplist();

skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0);   // 返回 false
skiplist.add(4);
skiplist.search(1);   // 返回 true
skiplist.erase(0);    // 返回 false，0 不在跳表中
skiplist.erase(1);    // 返回 true
skiplist.search(1);   // 返回 false，1 已被擦除
</pre>

**约束条件:**

- `0 <= num, target <= 20000`
- 最多调用  `50000`  次  `search`, `add`, 以及  `erase`操作。

## solution 题解

### C

```c



typedef struct {

} Skiplist;


Skiplist* skiplistCreate() {

}

bool skiplistSearch(Skiplist* obj, int target) {

}

void skiplistAdd(Skiplist* obj, int num) {

}

bool skiplistErase(Skiplist* obj, int num) {

}

void skiplistFree(Skiplist* obj) {

}

/**
 * Your Skiplist struct will be instantiated and called as such:
 * Skiplist* obj = skiplistCreate();
 * bool param_1 = skiplistSearch(obj, target);

 * skiplistAdd(obj, num);

 * bool param_3 = skiplistErase(obj, num);

 * skiplistFree(obj);
*/
```

### Go

```golang
type Skiplist struct {

}


func Constructor() Skiplist {

}


func (this *Skiplist) Search(target int) bool {

}


func (this *Skiplist) Add(num int)  {

}


func (this *Skiplist) Erase(num int) bool {

}


/**
 * Your Skiplist object will be instantiated and called as such:
 * obj := Constructor();
 * param_1 := obj.Search(target);
 * obj.Add(num);
 * param_3 := obj.Erase(num);
 */
```

### Python3

```python
class Skiplist:

    def __init__(self):


    def search(self, target: int) -> bool:


    def add(self, num: int) -> None:


    def erase(self, num: int) -> bool:



# Your Skiplist object will be instantiated and called as such:
# obj = Skiplist()
# param_1 = obj.search(target)
# obj.add(num)
# param_3 = obj.erase(num)
```

### JavaScript

```javascript
var Skiplist = function () {};

/**
 * @param {number} target
 * @return {boolean}
 */
Skiplist.prototype.search = function (target) {};

/**
 * @param {number} num
 * @return {void}
 */
Skiplist.prototype.add = function (num) {};

/**
 * @param {number} num
 * @return {boolean}
 */
Skiplist.prototype.erase = function (num) {};

/**
 * Your Skiplist object will be instantiated and called as such:
 * var obj = new Skiplist()
 * var param_1 = obj.search(target)
 * obj.add(num)
 * var param_3 = obj.erase(num)
 */
```

### Java

```java
class Skiplist {

    public Skiplist() {

    }

    public boolean search(int target) {

    }

    public void add(int num) {

    }

    public boolean erase(int num) {

    }
}

/**
 * Your Skiplist object will be instantiated and called as such:
 * Skiplist obj = new Skiplist();
 * boolean param_1 = obj.search(target);
 * obj.add(num);
 * boolean param_3 = obj.erase(num);
 */
```
