# Minimum Path Sum 最小路径和

[0000064] Medium

- https://leetcode-cn.com/problems/minimum-path-sum/

Topic Tags:

- [Array 数组](https://leetcode-cn.com/tag/array/)
- [Dynamic Programming 动态规划](https://leetcode-cn.com/tag/dynamic-programming/)

Similar Questions:

- [[0000062](https://leetcode-cn.com/problems/unique-paths/)] - [Unique Paths 不同路径](./0000062.unique-paths.md) (Medium)
- [[0000174](https://leetcode-cn.com/problems/dungeon-game/)] - [Dungeon Game 地下城游戏](./0000174.dungeon-game.md) (Hard)
- [[0000741](https://leetcode-cn.com/problems/cherry-pickup/)] - [Cherry Pickup 摘樱桃](./0000741.cherry-pickup.md) (Hard)

Given a _m_ x _n_ grid filled with non-negative numbers, find a path from top left to bottom right which _minimizes_ the sum of all numbers along its path.

**Note:** You can only move either down or right at any point in time.

**Example:**

<pre><strong>Input:</strong>
[
&nbsp; [1,3,1],
  [1,5,1],
  [4,2,1]
]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Because the path 1→3→1→1→1 minimizes the sum.
</pre>

## 翻译

给定一个包含非负整数的 *m* x *n*  网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例:**

<pre><strong>输入:</strong>
[
&nbsp; [1,3,1],
  [1,5,1],
  [4,2,1]
]
<strong>输出:</strong> 7
<strong>解释:</strong> 因为路径 1→3→1→1→1 的总和最小。
</pre>

## solution 题解

### C

```c


int minPathSum(int** grid, int gridSize, int* gridColSize){

}
```

### Go

```golang
func minPathSum(grid [][]int) int {

}
```

### Python3

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
```

### JavaScript

```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function (grid) {};
```

### Java

```java
class Solution {
    public int minPathSum(int[][] grid) {

    }
}
```
